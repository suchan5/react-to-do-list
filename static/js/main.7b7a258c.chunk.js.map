{"version":3,"sources":["components/habitAddForm.jsx","components/habit.jsx","components/habits.jsx","components/navbar.jsx","app.jsx","index.js"],"names":["HabitAddForm","inputRef","React","createRef","handleSubmit","event","preventDefault","new_habit","current","value","props","onAdd","onSubmit","this","type","className","placeholder","ref","Component","Habit","handleIncrement","onIncrement","habitzzz","handleDecrement","onDecrement","handleDelete","onDelete","name","count","onClick","Habits","habitxxx","habits","map","habitsss","id","onReset","Navbar","totalCount","App","state","index","indexOf","setState","filter","item","handleAdd","new_name","Date","now","handleReset","habit","length","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.7b7a258c.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nclass HabitAddForm extends Component {\n    inputRef = React.createRef(); // form에 입력된 input을 이제 처리해줘야함. 리액트에서는 querySelector같이 DOM에 직접 접근하지 않는다. 리액트에서는 Ref를 쓴다. 그리고 아래 render()에서 ref={this.inputRef}이렇게해서 사용하면 됨. 그럼 input form에 입력된 새로운 데이러를 핸들링 할 수 있음.  React.createRed()를 이용하면, 자바스크립트에서 DOM요소에 접근해서 그 요소에 대한 value나 클릭 이벤트나 처리하는 것처럼, 리액트는 바로 DOM요소에 접근하지 않고 필요할 때 이렇게 react 에서 제공하는 createRef를 사용해서 멤버변수를 정의한 다음에 그것을 원하는 해당하는 리액트 컴포넌트에 ref={this.inputRef}이런식으로 ref를 이용해서 연결하면 됩니다\n\n    handleSubmit = event => {\n        event.preventDefault(); // form에서 submit버튼을 누르면 페이지가 리프레시 되거나 다른 곳으로 가는게 디폴트이다. 근데 우리는 지금 싱글 페이지이므로 이렇게해서 리프레시를 막을 수 있다\n        // console.log(this.inputRef.current.value); // onSubmit이 잘되나 보려고 콘솔창에 current value 찍어봄. 잘된다 f12눌러서 크롬 개발자도구에서 확인 가능함\n        \n        const new_habit = this.inputRef.current.value;\n        new_habit && this.props.onAdd(new_habit); // 만약 새이름(new_habit)이 있다면, 텅텅 비어있지 않다면 props의 onAdd라는 함수에 이 new_name을 전달해줄꺼다\n        \n        this.inputRef.current.value=''; // 요렇게 인해주면 사용자가 새로운 습관(예. cleaning)을 타이핑하고 add하는 버튼을 눌렀을 때 input box에 cleaning이 남아있다\n    }\n\n    render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                <input type=\"text\" className=\"add-input\" placeholder=\"Add a new To Do here!\" ref={this.inputRef}/>\n                <button className=\"add-button\">Add</button>\n            </form>\n        );\n    }\n}\n\nexport default HabitAddForm;\n\n","import React, { Component } from 'react';\n\nclass Habit extends Component { // 여기는 따로 state object를 쓸 이유가 1도 없다. 데이터는 다 habits class component에서 props형태로 받아와서 쓸것이므로\n    handleIncrement = () => {\n        this.props.onIncrement(this.props.habitzzz); // this.props.onIncrement라고 써서 onIncrement라는 콜백 함수를 props으로 받아오기. 긍께 props으로 전달된 콜백함수들을 호출하게 되고 onIncrement(), 또 proprs으로 전달받은 각각의 데이터를 다시 인자로 전달해줍니다 this.props.habitzzz. 만약 헷갈린다면, 자바스크립트에서 함수를 다른함수의 인자로 전달하는 것, 즉 콜백함수를 공부하고 오시길\n    };\n\n    handleDecrement = () => {\n        this.props.onDecrement(this.props.habitzzz);\n    };\n\n    handleDelete = () => {\n        this.props.onDelete(this.props.habitzzz);\n    };\n    \n    render() {\n        const {name, count} = this.props.habitzzz; \n        return (\n            <li className=\"habit\">\n                <span className=\"habit-name\">{name}</span>\n                <span className=\"habit-count\">{count}</span>\n                <button className=\"habit-button habit-increase\" onClick={this.handleIncrement}><i className=\"fas fa-plus-square\"></i></button>  {/*클래스 안에 있는 함수를 호출하는 것이므로.. 멤버 변수.. this를 붙여줘 */}\n                <button className=\"habit-button habit-decrease\" onClick={this.handleDecrement}><i className=\"fas fa-minus-square\"></i></button>\n                <button className=\"habit-button habit-delete\" onClick={this.handleDelete}><i className=\"fas fa-trash\"></i></button>\n                \n            </li>\n\n        );\n    }\n}\n\nexport default Habit;\n\n// habit.jsx는 틀(골격)만 만들어두는거다. \n// habits.jsx에서 습관들을 추가하고 한다. habits.jsx에서 props로 만들어서 habit.jsx에서는 props를 이용해서 뿌린다.\n// habits.jsx의 Habits class components가 부모, habit.jsx의 Habit class components가 자식 (크롬 개발자도구 이용해서 보면 확 보임 ㅋㅋ)","import React, { Component } from 'react';\nimport Habit from './habit';\n\n\nclass Habits extends Component {  // class이므로 Habits이렇게 대문자로 바꿔주고, 아래 export default Habits;도 대문다로\n    handleIncrement = habitxxx => {\n         this.props.onIncrement(habitxxx); // onIncrement라는 콜백 함수를 props로 받습니다. 로직은 다 더 상위 컴포넌트인 app.jsx로 옮겼다. 여기서는 직접 로직을 작성하는 것보다 props를 이용해서 데이터를 받아다 쓸꺼임 \n    };\n\n    handleDecrement = habitxxx => {\n        this.props.onDecrement(habitxxx);\n    };\n\n    handleDelete = habitxxx => {\n        this.props.onDelete(habitxxx);\n    };\n\n    // handleReset = () => {\n    //     this.props.onReset();\n    // };  아래에 버튼을 요렇게 해서 'onClick= {this.handleReset}' 이런식으로 할 수도 있음 \n\n    render() {\n        return (\n            <>\n                <ul>\n                    {this.props.habits.map(habitsss => ( // state object에 있는 habits배열을 map을 이용해서 쭉 돌기. 그리고 그걸 골격(틀)인 Habit class component <Habits />에 '연결'해주는거임.  habitzzz라는 props로 데이터를 담아서 골격이자 틀인 habit.jsx에서 props를 통해 데이터를 틀에 뿌리기 <Habit habitzzz={habitsss} /> //  나중에 더 상위 컴포넌트인 app.jsx로 state object을 옮기므로 this.state.habits.map()이거에서 this.props.habits.map()이거로 바꿔줘야한다. props을 통해 데이터를 받아서 사용\n                        <Habit \n                            key={habitsss.id}  // 이런 경고 메세지가 구글 개발자툴 console에 뜰꺼다(index.js:1 Warning: Each child in a list should have a unique \"key\" prop.) . 리액트에서는 list를 사용할 때 반드시 key값을 가져야함. 같은 고유값을 가진 리스트항목은 다시 렌더링을 하지 않는식으로 리액트의 성능 개선을 key값으로 함. 리스트 항목마다 고유의 key값을 가져야함. 우리는 id를 주고 그걸 사용\n                            habitzzz={habitsss}    // habitzzz라는 이름의 props를 만들고 map으로 habitsss를 하나하나 돌린걸 담음\n                            onIncrement={this.handleIncrement}  // onIncrement라는 이름의 props를 만들고 handleIncrement라는 함수를 담음\n                            onDecrement={this.handleDecrement}\n                            onDelete={this.handleDelete}\n                        />  \n\n                    ))}\n                </ul>\n                <button className=\"habit-reset\" onClick={this.props.onReset}>Reset All</button>   {/* 위에 애들은 {this.handleIncrement} 이런식으로 하고 위에다 함수 handleIncrement() 불러왔다. 하지만 바로 이렇게해도 되는듯.... */}\n            </>\n        );\n    }\n}\n\nexport default Habits;","import React, { Component } from 'react';\n\nclass Navbar extends Component {  //Navbar로 대문자로 바꿔주고\n    render() {\n        return (\n            <nav className=\"navbar\">\n                <i className=\"navbar-logo fas fa-leaf\"></i>\n                <span>To Do List</span>\n                <span className=\"navbar-count\">{this.props.totalCount}</span>\n            </nav>\n        );\n    }\n}\n\nexport default Navbar;","import React, { Component } from 'react';\nimport './app.css';\nimport HabitAddForm from './components/habitAddForm';\nimport Habits from './components/habits';\nimport Navbar from './components/navbar';\n\n\nclass App extends Component { // Class이므로 App으로 대문자로 바꿔주고 \n  state = { // state object안에 습관들을 배열로 정의. 그리고 그 습관들 배열안에 각 습관들이 object형태로 \n    habits : [\n        {id: 1, name: 'Reading', count: 0},\n        {id: 2, name: 'Coding', count: 1},\n        {id: 3, name: 'Running', count:0},\n        {id: 4, name: 'Cycling', count: 5}\n        \n    ],\n  };\n\n  handleIncrement = habitxxx => {\n    const habits = [...this.state.habits];   // spread operator를 이용한 이유는 , 우리가 state object에 있는 저 배열을 직접적으로 건들면 안좋기 때문에 저거는 보존을하고, 여기다가 새로운 배열의 껍데기를 만들어서 복사한거임\n    const index = habits.indexOf(habitxxx);\n    habits[index].count++;\n    this.setState({ habits }); // this.setState({ habits: habits});랑 같다. \n  };\n\n  handleDecrement = habitxxx => {\n    const habits = [...this.state.habits];\n    const index = habits.indexOf(habitxxx);\n    const count = habits[index].count -1;\n    habits[index].count = count < 0 ? 0 : count;  // 사실 이 라인은 냄새나는 코드다. 나중에 왜 그런지 알려줄꺼래\n    this.setState({ habits }); // this.setState({ habits: habits});랑 같다. \n  };\n\n  handleDelete = habitxxx => {\n    const habits = this.state.habits.filter(item => item.id !== habitxxx.id); // item의 id가 인자로 넘어온 habitxxx의 id가 같다면 걔는 배열에서 delete. 삭제시키려고 클릭해서 넘어온 habitxxx의 아이디랑 match가 되면 배열에서 제거, match가 안되면 그냥 배열에 두는거임\n    this.setState({ habits }); // this.setState({ habits: habits});랑 같다. \n  };\n\n  handleAdd = new_name => {\n    const habits = [...this.state.habits, {id: Date.now(), name: new_name, count: 0}];\n    this.setState({ habits });\n  };\n\n  handleReset = () => {\n      const habits = this.state.habits.map(habit =>  {\n      habit.count = 0;\n      return habit;\n    });\n    this.setState({ habits });\n  };\n\n  render() {\n    return (\n      <>\n       <Navbar \n        totalCount={this.state.habits.filter(item => item.count > 0).length} \n      />\n       <HabitAddForm \n        onAdd={this.handleAdd}\n      />\n       <Habits\n        // key={this.state.habits.id}    // 엘레님은 app.jsx에서는 key안써주셨음.. 안써도 되는거임? habits.jsx에서는 <ul>을 썼으니까 해준건가? 리스트는 id를 줘서 관리한다고 하셨거덩. 그래서 app.jsx에서는 ul태그를 안써서 필요없나\n        habits={this.state.habits}    // 이름을 habits외에 다른거로 하면 에러가 뜬다..희한하네..왜지..\n        onIncrement={this.handleIncrement}  \n        onDecrement={this.handleDecrement}\n        onDelete={this.handleDelete}\n        onReset={this.handleReset}\n       /> \n      </>\n    );\n  }\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app';\nimport '@fortawesome/fontawesome-free/js/all.js';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}